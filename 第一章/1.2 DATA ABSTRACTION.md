A data type is a set of values and a set of operations on those values. So far, we have discussed in detail Java’s primitive data types: for example, the values of the primitive data type int are integers between $-2^{31}$ and $2^{31}$ - 1; the operations of int include +, *, -, /, %, <, and >. In principle, we could write all of our programs using only the built-in primitive types, but it is much more convenient to write programs at a higher level of abstraction. In this section, we focus on the process of defining and using data types, which is known as data abstraction (and supplements the function abstraction style that is the basis of SECTION 1.1). 

Programming in Java is largely ***based on*** building data types ***known as*** reference types with the familiar Java class. This style of programming is known as object-oriented programming, as it revolves around the concept of an object, an entity that holds a data type value. With Java’s primitive types we are largely `confined v. 限制，使局限；关押，监禁` to programs that operate on numbers, but with reference types we can write programs that operate on strings, pictures, sounds, any of hundreds of other abstractions that are available in Java’s standard libraries or on our booksite. Even more significant than libraries of predefined data types is that the range of data types available in Java programming is `openended adj. 可扩充的；无终止的`, because you can define your own data types to implement any abstraction `whatsoever 任何，无论什么`. 

An abstract data type (ADT) is a data type whose representation is hidden from the client. Implementing an ADT as a Java class is not very different from implementing a function library as a set of static methods. The primary difference is that we ***associate*** data ***with*** the function implementations and we hide the representation of the data from the client. When using an ADT, we focus on the operations specified in the API and ***pay no attention to*** the data representation; when implementing an ADT, we focus on the data, then implement operations on that data. 

Abstract data types are important because they support encapsulation in program design. In this book, we use them as a means to 

- Precisely specify problems in the form of APIs for use by diverse clients 
- Describe algorithms and data structures as API implementations 

Our primary reason for studying different algorithms for the same task is that performance characteristics differ. Abstract data types are an appropriate framework for the study of algorithms because they allow us to put knowledge of algorithm performance to `immediate adj. 立刻的，即时的` use: we can substitute one algorithm for another to improve performance for all clients without changing any client code.

### Using abstract data types
You do not need to know how a data type is implemented ***in order to*** be able to use it, so we begin by describing how to write programs that use a simple data type named Counter whose values are a name and a `nonnegative adj. 非负的` integer and whose operations are create and initialize to zero, increment by one, and examine the current value. This abstraction is useful in many contexts. For example, it would be reasonable to use such a data type in electronic voting software, to ensure that the only thing that a voter can do is increment a chosen candidate’s `tally n. 记录，得分；账单` by one. Or, we might use a Counter to keep track of fundamental operations when analyzing the performance of algorithms. To use a Counter, you need to learn our mechanism for specifying the operations defined in the data type and the Java language mechanisms for creating and manipulating data-type values. Such mechanisms are critically important in modern programming, and we use them throughout this book, so this first example is worthy of careful attention. 

**API for an abstract data type**. To specify the behavior of an abstract data type, we use an application programming interface (API), which is a list of constructors and instance methods (operations), with an informal description of the effect of each, as in this API for Counter:
